<!doctype html>
<meta charset="utf-8" />
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
  body { font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 2rem; }
  .layout { display: flex; align-items: flex-start; gap: 1.5rem; }
  #stage { 
    font-size: 14pt; font-weight: 700; letter-spacing: 0.5px;
    display: grid; place-items: center; width: 100%; height: 4in;
    margin: 0; user-select: none;
    contain: layout paint; /* isolate paints */
    will-change: contents; /* we change text frequently */
    text-align: center;
  }
  button { background: #0d6efd; color: #fff; border: none; padding: 0.5rem 0.75rem; border-radius: 6px; cursor: pointer; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  .panel { width: 4in; }
  #toggle { width: 100%; display: block; }
  .nav-row { width: 100%; display: flex; gap: 0.5rem; }
  .nav-row button { flex: 1; }
  .settings { min-width: 16rem; width: auto; }
  .control { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; margin: 0.5rem 0; }
  label { display: inline-block; min-width: 6rem; }
  .row { margin: 0.5rem 0; }
  /* Stats table */
  #statsTable td.value { white-space: nowrap; }
  #statsTable td.plusminus {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    text-align: right;
    white-space: nowrap;
    min-width: 8ch;
  }
  #statsTable td.value .num {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    display: inline-block;
    text-align: right;
    min-width: 8ch; /* numeric column width */
  }
  #statsTable td.value .unit { margin-left: 0.35ch; opacity: 0.9; }
  #statsTable td.value .effms .num {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    display: inline-block;
    text-align: right;
    min-width: 6ch; /* width for ms number */
  }
  #statsTable td.plusminus .num {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    display: inline-block;
    text-align: right;
    min-width: 6ch;
  }
  #statsTable td.plusminus .unit { margin-left: 0.35ch; opacity: 0.9; }
</style>

<div class="d-flex justify-content-center">
  <div class="app-group">
    <h1 class="text-center" style="margin:0 0 0.5rem 0;">WordFlow</h1>
    <div class="d-flex align-items-start justify-content-center gap-3 app-cards">
      <div class="col-auto">
      <div class="card panel p-0">
        <div class="card-body p-0">
          <div id="stage" aria-live="off">Ready…</div>
        </div>
      </div>
      <div class="card mt-2 panel p-0">
        <div class="card-body p-2">
          <button id="toggle" class="btn btn-primary w-100">Start</button>
          <div class="nav-row" style="margin-top:0.5rem">
            <button id="prev" class="btn btn-primary">◀ Prev</button>
            <button id="next" class="btn btn-primary">Next ▶</button>
          </div>
        </div>
      </div>
      </div>
      <div class="col-auto settings" aria-label="Settings">
        <div class="card">
          <div class="card-header">Settings</div>
          <div class="card-body">
            <div class="mb-3">
              <label for="minMs" class="form-label">Min interval (ms)</label>
              <input id="minMs" type="number" class="form-control" value="250" min="1" max="2000" step="5">
            </div>
            <div class="mb-3">
              <label for="maxChars" class="form-label">Max characters</label>
              <input id="maxChars" type="number" class="form-control" value="12" min="1" max="2000" step="1">
            </div>
            <div class="form-check">
              <input id="snap" class="form-check-input" type="checkbox">
              <label class="form-check-label" for="snap">Snap to display</label>
            </div>
          </div>
        </div>
        <div class="card mt-3">
          <div class="card-header">Statistics</div>
        <div class="card-body">
          <table class="table table-sm mb-0" id="statsTable" aria-label="Statistics">
            <tbody>
              <tr>
                <th scope="row">Display</th>
                <td class="value">
                  <span class="num" id="stat-display-num">–</span> <span class="unit">Hz</span>
                </td>
                <td class="plusminus"><span class="num" id="stat-display-ms-num">–</span> <span class="unit">ms</span></td>
              </tr>
              <tr>
                <th scope="row">Target</th>
                <td class="value">
                  <span class="num" id="stat-target-num">–</span> <span class="unit">fps</span>
                </td>
                <td class="plusminus"><span class="num" id="stat-target-ms-num">–</span> <span class="unit">ms</span></td>
              </tr>
              <tr>
                <th scope="row">Actual</th>
                <td class="value">
                  <span class="num" id="stat-actual-num">–</span> <span class="unit">fps</span>
                </td>
                <td class="plusminus"><span class="num" id="stat-actual-ms-num">–</span> <span class="unit">ms</span></td>
              </tr>
              <tr>
                <th scope="row">Avg</th>
                <td class="value"><span class="num" id="stat-avg-num">–</span> <span class="unit">ms</span></td>
                <td class="plusminus"><span class="sym">±</span> <span class="num" id="stat-std-num">0.00</span> <span class="unit">ms</span></td>
              </tr>
              <tr>
                <th scope="row">Frames</th>
                <td class="value"><span class="num" id="stat-frames-num">–</span></td>
                <td class="plusminus"></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      </div>
    </div>
  </div>
</div>

<script>
// Text loaded from TheTimeMachine.txt
let text = '';
let tokens = [];

const stage = document.getElementById('stage');
const minMsInput = document.getElementById('minMs');
const snapChk  = document.getElementById('snap');
const statTargetNum = document.getElementById('stat-target-num');
const statActualNum = document.getElementById('stat-actual-num');
const statActualMsNum = document.getElementById('stat-actual-ms-num');
const statAvgNum    = document.getElementById('stat-avg-num');
const statStdNum    = document.getElementById('stat-std-num');
const statFramesNum = document.getElementById('stat-frames-num');
const statDisplayNum   = document.getElementById('stat-display-num');
const statDisplayMsNum = document.getElementById('stat-display-ms-num');
const toggleBtn = document.getElementById('toggle');
const maxCharsInput = document.getElementById('maxChars');
const prevBtn  = document.getElementById('prev');
const nextBtn  = document.getElementById('next');

let running = false;
let idx = 0;
let acc = 0;
let last = 0;
let periodMs = 0; // set below via updatePeriod()
let maxChars = Math.max(1, Number(maxCharsInput.value) || 1);
let measuredDisplayHz = null; // determined via RAF measurement

// rolling measurements
const intervals = [];
const MAX_SAMPLES = 120;
let lastSwapTime = 0;
// history of how many tokens were consumed per shown frame
const history = [];

// Disable controls until text loads
toggleBtn.disabled = true;
prevBtn.disabled = true;
nextBtn.disabled = true;

function updateRunButtons() {
  // Toggle button label reflects state
  toggleBtn.textContent = running ? 'Stop' : 'Start';
}

// Load and prepare text
const loadPromise = (async () => {
  try {
    stage.textContent = 'Loading text…';
    const res = await fetch('TheTimeMachine.txt', { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const raw = await res.text();
    // Normalize whitespace
    const normalized = raw.replace(/\r\n?|\n/g, ' ').replace(/\s+/g, ' ').trim();
    window._bookText = normalized; // debug handle
    // store
    window._bookLen = normalized.length;
    // assign
    // assign to outer-scope `text`
    text = normalized;
    tokens = normalized.split(' ').filter(Boolean);
    if (!text || text.length === 0 || tokens.length === 0) throw new Error('No text found');
    stage.textContent = 'Ready…';
    // Enable controls now that content is ready
    running = false;
    updateRunButtons();
    toggleBtn.disabled = false;
    prevBtn.disabled = false;
    nextBtn.disabled = false;
  } catch (err) {
    console.error(err);
    stage.textContent = 'Failed to load TheTimeMachine.txt';
    const hint = (location.protocol === 'file:')
      ? 'Serve this folder over HTTP (e.g., python3 -m http.server).'
      : 'Ensure index.html and TheTimeMachine.txt are served from the same origin.';
    text = `Failed to load TheTimeMachine.txt. ${hint}`;
    tokens = text.split(' ');
    // Allow manual stepping even on error text
    running = false;
    updateRunButtons();
    toggleBtn.disabled = false;
    prevBtn.disabled = false;
    nextBtn.disabled = false;
  }
})();

function effectivePeriodMs(minMs) {
  if (!snapChk.checked) return minMs;
  // Optionally “snap” to multiples of the display’s refresh period
  // so spacing is uniform (useful if you want 30 on a 60 Hz screen).
  // Prefer measured refresh rate; fall back to 60 if unknown.
  const displayRate = measuredDisplayHz || 60;
  const refreshMs = 1000 / displayRate;
  // choose the smallest integer multiple >= minMs (respect minimum)
  const steps = Math.max(1, Math.ceil(minMs / refreshMs));
  return steps * refreshMs;
}

function updatePeriod() {
  const minMs = Math.max(1, Number(minMsInput.value));
  periodMs = effectivePeriodMs(minMs);
}

function computeChunk(startIndex) {
  const total = tokens.length;
  let remaining = Math.max(1, Math.min(maxChars, 1000000));
  const chunk = [];
  let cursor = startIndex;
  for (let i = 0; i < total; i++) {
    const token = tokens[cursor];
    const extra = token.length + (chunk.length ? 1 : 0);
    if (chunk.length === 0 && token.length > remaining) {
      // fallback: include the whole long word (do not break words)
      return { chunk: [token], consumed: 1, nextIndex: (cursor + 1) % total };
    }
    if (extra <= remaining) {
      chunk.push(token);
      remaining -= extra;
      cursor = (cursor + 1) % total;
    } else {
      break;
    }
  }
  return { chunk, consumed: chunk.length, nextIndex: cursor };
}

function showNext() {
  if (!tokens || tokens.length === 0) return; // nothing to show yet
  const { chunk, consumed, nextIndex } = computeChunk(idx);
  stage.textContent = chunk.join(' ');
  idx = nextIndex;
  history.push(consumed);

  // record actual interval
  if (running) {
    const now = performance.now();
    if (lastSwapTime) {
      const dt = now - lastSwapTime;
      intervals.push(dt);
      if (intervals.length > MAX_SAMPLES) intervals.shift();

      const mean = intervals.reduce((a,b)=>a+b,0) / intervals.length;
      const variance = intervals.reduce((a,b)=>a + (b-mean)*(b-mean), 0) / intervals.length;
      const stdev = Math.sqrt(variance);

      const fmt = (v, d=2) => Number(v).toFixed(d);
      const avgMs = mean;
      const stdMs = stdev;
      const tgtFps = 1000 / periodMs;
      const tgtMs  = periodMs;
      const actFps = 1000 / mean;
      const statTargetMsNum = document.getElementById('stat-target-ms-num');
      statTargetNum.textContent = fmt(tgtFps);
      statTargetMsNum.textContent = fmt(tgtMs);
      statActualNum.textContent = fmt(actFps);
      if (statActualMsNum) statActualMsNum.textContent = fmt(avgMs);
      statAvgNum.textContent = fmt(avgMs);
      statStdNum.textContent = fmt(stdMs);
      statFramesNum.textContent = String(intervals.length);
    }
    lastSwapTime = now;
  }
}

function loop(now) {
  if (!running) return;
  if (!last) last = now;
  acc += (now - last);
  last = now;

  // Advance at most one frame; if a frame ran long, we do NOT catch up.
  if (acc >= periodMs) {
    acc -= periodMs; // keep remainder to avoid long-term drift
    showNext();
  }
  requestAnimationFrame(loop);
}

async function start() {
  // Ensure text is loaded before starting
  try { await loadPromise; } catch (_) { /* handled in loader */ }
  updatePeriod();
  running = true;
  updateRunButtons();
  idx = 0;
  acc = 0; last = 0; lastSwapTime = 0;
  intervals.length = 0;
  history.length = 0;
  requestAnimationFrame(loop);
}
function stop() { running = false; updateRunButtons(); }

minMsInput.addEventListener('change', () => {
  updatePeriod();
  // keep current accumulator; change takes effect immediately
});
snapChk.addEventListener('change', updatePeriod);
toggleBtn.addEventListener('click', () => {
  if (running) { stop(); }
  else { start(); }
});
maxCharsInput.addEventListener('change', () => {
  maxChars = Math.max(1, Number(maxCharsInput.value) || 1);
});
prevBtn.addEventListener('click', async () => {
  if (!tokens || tokens.length === 0) {
    try { await loadPromise; } catch (_) {}
  }
  if (running) stop();
  if (!tokens || tokens.length === 0) return;
  if (history.length === 0) return;
  const total = tokens.length;
  const consumed = history.pop();
  idx = (idx - consumed + total) % total;
  const { chunk } = computeChunk(idx);
  stage.textContent = chunk.join(' ');
});
nextBtn.addEventListener('click', async () => {
  if (!tokens || tokens.length === 0) {
    try { await loadPromise; } catch (_) {}
  }
  if (running) stop();
  showNext();
});

// Pause cleanly in background tabs (RAF throttles anyway)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) { stop(); }
  else {
    // Re-measure when the tab becomes visible again (monitor may have changed)
    scheduleDisplayRateMeasurement();
  }
});

// --- Display refresh rate measurement (via requestAnimationFrame) ---
function measureDisplayRate(samples = 120, timeoutMs = 2000) {
  return new Promise((resolve) => {
    const times = [];
    let start = null;
    let done = false;

    function finish() {
      if (done) return; done = true;
      if (times.length < 2) { resolve(null); return; }
      const dts = [];
      for (let i = 1; i < times.length; i++) dts.push(times[i] - times[i-1]);
      // Robust average: trim outliers based on median ± 20%
      const sorted = [...dts].sort((a,b)=>a-b);
      const median = sorted[Math.floor(sorted.length/2)];
      const low = median * 0.8;
      const high = median * 1.2;
      const trimmed = dts.filter(dt => dt >= low && dt <= high);
      const use = trimmed.length >= Math.max(5, Math.floor(dts.length*0.5)) ? trimmed : dts;
      const mean = use.reduce((a,b)=>a+b,0) / use.length;
      const hz = 1000 / mean;
      resolve(hz);
    }

    function tick(t) {
      if (!start) start = t;
      times.push(t);
      if (times.length >= samples || (t - start) >= timeoutMs) {
        finish();
      } else {
        requestAnimationFrame(tick);
      }
    }

    // If the tab is hidden, rAF is heavily throttled; bail out fast.
    if (document.hidden) { resolve(null); return; }
    requestAnimationFrame(tick);
    setTimeout(finish, timeoutMs + 100); // safety valve
  });
}

async function scheduleDisplayRateMeasurement() {
  const hz = await measureDisplayRate();
  if (hz && Number.isFinite(hz)) {
    measuredDisplayHz = hz;
    const ms = 1000 / hz;
    const fmt = (v, d=2) => Number(v).toFixed(d);
    if (statDisplayNum) statDisplayNum.textContent = fmt(hz);
    if (statDisplayMsNum) statDisplayMsNum.textContent = fmt(ms);
    // If snapping is on, recompute target period now that we know the rate
    updatePeriod();
  } else {
    // Unknown; clear display (keeps previous value if already measured)
    if (!measuredDisplayHz) {
      if (statDisplayNum) statDisplayNum.textContent = '–';
      if (statDisplayMsNum) statDisplayMsNum.textContent = '–';
    }
  }
}

// Kick off an initial measurement shortly after load
scheduleDisplayRateMeasurement();
</script>
